[{"categories":[],"content":"网站与网页 网页是网站的一部分（网站是网页的集合），通常是HTML格式的文件，需要通过浏览器来阅读。 网页是构成网站的基本元素，通常由图片，链接，文字，声音，视频等元素组成。网页常是以.html或.htm后缀结尾的文件，因此俗称html文件。 （HTML：超文本标记语言，网页的标准语言。HTML并不是一门编程语言，而是一门描述性的标记语言） ","date":"2022-06-08","objectID":"/html/:1:0","tags":[],"title":"HTML标签","uri":"/html/"},{"categories":[],"content":"浏览器 五大浏览器：IE，谷歌，火狐，edge，sufari 浏览器内核（了解）： ","date":"2022-06-08","objectID":"/html/:2:0","tags":[],"title":"HTML标签","uri":"/html/"},{"categories":[],"content":"web标准 由w3c组织和其他标准化组织指定的一系列标准的集合，遵循web标准使得不同开发人员写出的页面更加统一。 web标准的构成（三者相互分离）： ","date":"2022-06-08","objectID":"/html/:3:0","tags":[],"title":"HTML标签","uri":"/html/"},{"categories":[],"content":"html标签: ","date":"2022-06-08","objectID":"/html/:4:0","tags":[],"title":"HTML标签","uri":"/html/"},{"categories":[],"content":"标签分类及结构 双标签： \u003chtml\u003e \u003c/html\u003e 单标签： \u003cbr /\u003e 包含关系 \u003chead\u003e \u003ctitle\u003e\u003c/title\u003e \u003c/head\u003e 并列关系 \u003chead\u003e\u003c/head\u003e \u003cbody\u003e\u003c/body\u003e 网页基本结构骨架： \u003c!DOCTYPE html\u003e//文档声明标签 \u003chtml lang=\"en\"\u003e//文档显示语言标签: \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e//通过\u003cmeta\u003e标签的chrset属性规定文档使用的字符编码方式 \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e用vscode创建网页\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e abababaababababab \u003c/body\u003e \u003c/html\u003e ","date":"2022-06-08","objectID":"/html/:4:1","tags":[],"title":"HTML标签","uri":"/html/"},{"categories":[],"content":"常用标签 标题标签 \u003ch1\u003e一级标题\u003c/h1\u003e \u003ch2\u003e二级标题\u003c/h2\u003e \u003ch3\u003e三级标题\u003c/h3\u003e \u003ch4\u003e四级标题\u003c/h4\u003e \u003ch5\u003e五级标题\u003c/h5\u003e \u003ch6\u003e六级标题\u003c/h6\u003e 段落与换行标签(不同段落之间会有间隙，但强制换行没有间隙) \u003cp\u003e第一段阿巴阿巴\u003c/p\u003e \u003cp\u003e第二段阿巴阿巴\u003c/p\u003e \u003cp\u003e第二段(强制换行)\u003cbr/\u003e阿巴阿巴\u003c/p\u003e 文本格式化标签 \u003cstrong\u003e加粗1\u003c/strong\u003e \u003cb\u003e加粗2\u003c/b\u003e \u003cem\u003e倾斜1\u003c/em\u003e \u003ci\u003e倾斜2\u003c/i\u003e \u003cdel\u003e删除线1\u003c/del\u003e \u003cs\u003e删除线2\u003c/s\u003e \u003cins\u003e下划线1\u003c/ins\u003e \u003cu\u003e下划线2\u003c/u\u003e 注释标签 （ctrl+/）与特殊字符 \u003c!--此为注释--\u003e 和-标签（无语义，用于布局） \u003cdiv\u003e第一个盒子，div独占一行\u003c/div\u003e \u003cspan\u003e第二个盒子，span可放多个\u003c/span\u003e \u003cspan\u003e第三个盒子\u003c/span\u003e 图像标签(设置宽高时如果只改变一个则纵横比不变) \u003cimage src=\"文件路径2\" alt=\"此为图像无法显示时的替换文本\" title=\"鼠标移动到图片上的提示文本\" width=\"500\" height=\"100\" border=\"15\"/\u003e 超链接标签（由一个页面链接到另一个页面） \u003c!----\u003ca herf=\"跳转的链接地址\" target=\"目标窗口的打开方式_self为默认模值，_blank为在新窗口打开\"\u003e文本或图像\u003c/a\u003e---\u003e \u003c!--1.外部链接:访问外部的qi'ta--\u003e \u003cbr/\u003e \u003ca href=\"http://www.baidu.com\" target=\"_blank\"\u003e百度\u003c/a\u003e \u003ca href=\"http://www.qq.com\"\u003e腾讯\u003c/a\u003e \u003c!--2.内部链接:访问网站内部的其他页面，直接链接内部页面名称即可--\u003e \u003ca href=\"vscode创建页面.html\"\u003e例子\u003c/a\u003e \u003c!--3.空链接:用于占位，链接地址为空--\u003e \u003ca href=\"#\"\u003e空链接\u003c/a\u003e \u003c!--4.下载链接:用于下载文件，可直接链接文件地址--\u003e \u003ca href=\"img.zip\"\u003e下载文件\u003c/a\u003e \u003c!--网页元素链接：链接的内容不仅仅可以是文字，也可以是其他的网页元素，如文本/表格/音频/视频--\u003e \u003ca href=\"http:www.baidu.com\"\u003e\u003cimg src=\"img.jpg\"/\u003e\u003c/a\u003e \u003c!--锚点链接:用于网页中某些位置的跳转，\u003c1\u003e.在href中设置#名字A\u003c2\u003e在目标位置标签中添加一个id属性=名字A--\u003e \u003ca href=\"#锚点1\"\u003e锚点一\u003c/a\u003e \u003ch3 id=\"锚点1\"\u003e锚点一详情\u003c/h3\u003e 表格标签（用于显示数据） table标签创建表格，tr标签创建行，td标签创建相关单元格。对于表格第一行的单元格，使用th代替td作为表头标签进行突出 表格属性一般在css中进行设置，此处做了解 表格结构标签：由于表格可能很长，因此将表格分为头部与主体两大部分可以更好地表示表格语义 \u003c!-- 表格 --\u003e \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e\u003cth\u003e姓名\u003c/th\u003e \u003cth\u003e性别\u003c/th\u003e \u003cth\u003e年龄\u003c/th\u003e\u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e\u003ctd\u003eaa\u003c/td\u003e \u003ctd\u003e男\u003c/td\u003e \u003ctd\u003e11\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003ebb\u003c/td\u003e \u003ctd\u003e男\u003c/td\u003e \u003ctd\u003e12\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003ecc\u003c/td\u003e \u003ctd\u003e男\u003c/td\u003e \u003ctd\u003e15\u003c/td\u003e\u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 合并单元格（跨行colspan与跨列rowspan） 先找到目标单元格，按照跨行/列合并添加属性（数字代表合并单元格个数），再删掉多余行 \u003c!-- 合并单元格 --\u003e \u003ctable width=\"500\" heigth=\"249\" border=\"1\" cellspacing=\"0\"\u003e \u003cthead\u003e \u003ctr\u003e\u003cth\u003e姓名\u003c/th\u003e \u003cth\u003e性别\u003c/th\u003e \u003cth\u003e年龄\u003c/th\u003e\u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e\u003ctd\u003eaa\u003c/td\u003e \u003ctd colspan=\"2\"\u003e男\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd rowspan=\"2\"\u003ebb\u003c/td\u003e \u003ctd\u003e男\u003c/td\u003e \u003ctd\u003e12\u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e男\u003c/td\u003e \u003ctd\u003e15\u003c/td\u003e\u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 列表标签（用于布局页面） \u003c!-- 列表标签(相关属性在css中设置) --\u003e \u003c!-- 无序(ul中只可放li，li中可放其他元素) --\u003e \u003cul\u003e \u003cli\u003elll\u003c/li\u003e \u003cli\u003elol\u003c/li\u003e \u003cli\u003e\u003cp\u003e123\u003c/p\u003e\u003c/li\u003e \u003c/ul\u003e \u003c!-- 有序(了解,0l中只可放li，li中可放其他元素) --\u003e \u003col\u003e \u003cLI\u003eno.1\u003c/LI\u003e \u003cLI\u003eno.2\u003c/LI\u003e \u003cLI\u003eno.3\u003c/LI\u003e \u003c/ol\u003e \u003c!-- 自定义(dl中只可放dt或dd（个数不限），dd或dt中可放其他元素) --\u003e \u003cdl\u003e \u003cdt\u003e名词1\u003c/dt\u003e \u003cdd\u003e名词1解释1\u003c/dd\u003e \u003cdd\u003e名词1解释2\u003c/dd\u003e \u003c/dl\u003e 表单标签（用于收集用户信息，由表单域form，表单控件（表单元素）及提示信息3部分组成） \u003c!-- 1.表单域标签\u003cform\u003e --\u003e \u003cform action=\"url地址\" method=\"提交方式\" name=\"表单域名称，用于区别不同表单\"\u003e \u003c/form\u003e \u003c!-- 2.表单元素标签 --\u003e \u003c!-- 2.1 input标签（不同type属性及其他属性） --\u003e \u003c!-- 文本框 --\u003e \u003c!-- value为值，规定了输入元素的值 --\u003e \u003c!-- maxlength规定了输入元素的最大长度 --\u003e 用户名：\u003cinput type=\"text\" name=\"username\" value=\"请输入用户名\" maxlength=\"4\"\u003e\u003cbr/\u003e \u003c!-- 密码框 --\u003e 密码：\u003cinput type=\"password\" name=\"pwd\" maxlength=\"6\"\u003e\u003cbr/\u003e \u003c!-- 单选和多选可设置checked属性，当页面打开时默认选中这个选项（多选中可以设置一个以上） --\u003e \u003c!-- 单选 --\u003e \u003c!-- name为表单元素的名字，此处单选name必须一致才可保证单选 --\u003e 性别：男\u003cinput type=\"radio\" name=\"sex\" checked=\"checked\"\u003e女\u003cinput type=\"radio\" name=\"sex\"\u003e\u003cbr/\u003e \u003c!-- 多选 --\u003e 爱好：吃饭\u003cinput type=\"checkbox\" name=\"hobby\" checked=\"checked\"\u003e睡觉\u003cinput type=\"checkbox\" name=\"hobby\" checked=\"checked\"\u003e喝水\u003cinput type=\"checkbox\" name=\"hobby\"\u003e\u003cbr/\u003e \u003c!-- 提交：将表单域中的值提交给后台服务器 --\u003e \u003cinput type=\"submit\" value=\"提交\"\u003e \u003c!-- 重置：将表单域中的值重置为初始状态 --\u003e \u003cinput type=\"reset\" value=\"重置\"\u003e \u003c!-- 普通按钮：可点击，用于通过js启动脚本 --\u003e \u003cinput type=\"button\" value=\"获取短信验证码\"\u003e \u003c!-- 文件域：用于上传文件 --\u003e 上传文件：\u003cinput type=\"file\"\u003e \u003c!-- 2.2 label标签(不是表单元素但常与input一起用)：用于绑定表单元素，点击标签内的文本，自动将光标转到对应的表单元素（for属性和对应元素id相同）上，用于优化用户体验 --\u003e 性别:\u003clabel for=\"sex\"\u003e男\u003c/label\u003e\u003cinput type=\"radio\" name=\"sex\" id=\"sex\"\u003e \u003c!-- 2.3 select标签：给用户提供下拉列表中的选项 --\u003e 籍贯： \u003cselect\u003e \u003coption\u003e北京\u003c/option\u003e \u003coption\u003e上海\u003c/option\u003e \u003coption\u003e深圳\u003c/option\u003e \u003coption selected=\"selected\"\u003e河南\u003c/option\u003e \u003c/select\u003e \u003c!-- 2.4 textarea文本域标签（其中的row和col一般在开发中不会使用，一般用css控制行列） --\u003e 文本域：\u003ctextarea rows=\"3\" cols=\"20\"\u003e这些是打开页面时默认的文本内容 \u003c/textarea\u003e 相对路径与绝对路径 相对路径：一引用文件夹所在位置为参考基础而建立的目录路径 绝对路径：指目录下的绝对位置，通常从盘符开始的路径 ","date":"2022-06-08","objectID":"/html/:4:2","tags":[],"title":"HTML标签","uri":"/html/"},{"categories":[],"content":"排序 稳定性 (排序前A在B前B，排序后A=B，A仍在B前) 内排序（排序记录均放置在内存中）与外排序： 内排序性能: 时间性能：关键字比较次数及记录移动次数应尽可能少 辅助空间：存放待排序及算法运行所用空间 复杂性：算法复杂性影响排序性 #define MAXSIZE 10 //数组个数最大值 struct SqList{ int r[MAXSIZE+1];//储存要排序的数组 int length; } void swap(SqList *L,int i,int j){ int temp=L-\u003er[i]; L-\u003er[i]=L-\u003er[j]; L-\u003er[j]=temp; } ","date":"2022-06-08","objectID":"/sort/:0:0","tags":[],"title":"关于排序","uri":"/sort/"},{"categories":[],"content":"排序种类 插入排序：好：0 moves, n-1 comparisons 坏：（n-1）n/2 moves 和comparisons n位swap 归并排序：T(n)=2*T([n/2])+cn 快速排序： 坏：（n-1）n/2 moves comparisons ","date":"2022-06-08","objectID":"/sort/:1:0","tags":[],"title":"关于排序","uri":"/sort/"},{"categories":[],"content":"插入排序 直接插入排序：将一个记录插入到已知有序序列中。 void InsertSort(SqList *L) { for(int i=2;i\u003cL-\u003elength;i++) { if(L-\u003er[i]\u003cL-\u003er[i-1]) { L-\u003er[0]=L-\u003er[i];//哨兵r[0]用于存储需要插入的记录 for(int j=i-1;L-\u003er[j]\u003eL-\u003er[i];j--)//遍历必r[0]大的记录并后移 { L-\u003er[j+1]=L-\u003e[j]; } L-\u003er[j]=L-\u003er[0];//将数据r[0]放入空位 } } } 希尔排序：设定一个增量序列（质数序列，递减，最终为1），将以每一个增量作为间隔的少数记录做一次直接插入排序，由基本有序逐渐完善到整体有序。 void ShellSort(SqList *L) { int increment=L-\u003elength; do { increment=incrament/3+1; for(int i=increment+1;i\u003c=L-\u003elength;i++) { if(L-\u003er[i]\u003cL-\u003er[i-increment]) { L-\u003er[0]=L-\u003er[i]; for(int j=i-increment;j\u003e0\u0026\u0026L-\u003er[0]\u003cL-\u003er[j];j-=increment) { L-\u003er[j+increment]=L-\u003er[0]; } } } } while(increment\u003e1); } ","date":"2022-06-08","objectID":"/sort/:1:1","tags":[],"title":"关于排序","uri":"/sort/"},{"categories":[],"content":"交换排序 冒泡排序： 快速排序：设计一个中心枢纽，枢纽左边的都是比他小的，右边的都是比他大的。左右边部分继续设置枢纽，进行排序，依此递归。 void QuickSort(SqList *L) { QSort(L,1,L-\u003elength); } void QSort(SqList *L,int low,int high) { int pivot; if(low\u003chigh) { pivot=Partition(L,low,high); QSort(L,low,pivot-1); QSort(L,pivot+1,high); } } int Partition(SqList *L,int low,int high) { int pivotKey; pivotkey=L-\u003er[low]; L-\u003er[0]=pivotkey; while(low\u003chigh) { while(low\u003chigh\u0026\u0026L-\u003er[high]\u003e=pivotkey){high--;} L-\u003er[low]=L-\u003er[high]; while(low\u003ehigh\u0026\u0026L-\u003e[low]\u003c=pivotkey){low++} L-\u003er[high]=L-\u003er[low]; } L-\u003er[llow]=L-\u003er[0]; return low; } ","date":"2022-06-08","objectID":"/sort/:1:2","tags":[],"title":"关于排序","uri":"/sort/"},{"categories":[],"content":"选择排序 直接选择排序 void SelectSort(SqList *L) { int i,j,min; for(i=1;i\u003cL-\u003elength;i++) { min=i; for(j=i+1;j\u003cL-\u003elength;j++) { if(L-\u003er[j]\u003cL-\u003er[min]) { min=j; } } if(i!=min) { swap(L,min,i); } } } 堆排序 void HeapSort(SqList *L) { int i; for(i=L-\u003elength/2;i\u003e0;i--) { HeapAdjust(L,i,L-\u003elength); } for(i=L-\u003elength;i\u003e1;i--) { swap(L,1,i); HeapAdjust(L,1,i-1); } } void HeapAdjust(Aqlist *L,int s,int m) { int temp,j; temp=L-\u003er[s]; for(j=2*s;j\u003cm;j*=2) { if(j\u003cm \u0026\u0026 L-\u003er[j]\u003cL-\u003er[j+1]) { ++j; } if(temp\u003e=L-\u003er[j]) { break; } L-\u003er[s]=L-\u003er[j]; s=j; } L-\u003er[s]=temp; } ###　归并排序 void MergeSort(SqList *L) { MSort(L-\u003er,L-\u003er,1.L-\u003elength); } voidMSort(int SR[],int TR[],int s,int t) { int m; int TR2[MAXSIZE+1]; if(s==t) {TR1[s]=SR[s];} else { m=(s+t)/2; MSort(SR,TR,s,m); MSort(SR,TR,m+1,t); Merge(TR2,TR1,s,m,t); } } void Merge(int SR[],int TR[],int i,int m,int n) { if (SR[i]\u003cSR[j]) { TR[K]=SR[i++]; } else{TR[k]=SR[j++];} } if(i\u003c=m) { for(l=0;l\u003cm-i,l++ {TR[k+1]=SR[i+1];} } if(j\u003c=n) { for(l=0;l\u003cn-j,l++ {TR[k+1]=SR[i+1];} } ","date":"2022-06-08","objectID":"/sort/:1:3","tags":[],"title":"关于排序","uri":"/sort/"}]