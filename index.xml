<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ohhhhhhh</title>
    <link>https://Mortyda.github.io/</link>
    <description>Recent content on ohhhhhhh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 24 May 2022 14:10:51 +0800</lastBuildDate><atom:link href="https://Mortyda.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于markdowm</title>
      <link>https://Mortyda.github.io/post/blog/</link>
      <pubDate>Tue, 24 May 2022 14:10:51 +0800</pubDate>
      
      <guid>https://Mortyda.github.io/post/blog/</guid>
      <description>markdown 第一篇文章，介绍了markdown语法的少部分效果
一级标题 二级标题 三级标题 四级标题 五级标题 六级标题  这是一段引用
 有序列表：
 第一步 第二步 第三步  无序列表：
 第一步 第二步 第三步  或者是：
 第n步(这里使用的是*号)  任务列表：
明日计划：
  吃饭
  睡觉
  打豆豆
  代码块：
int main(){ return 0 } 数学公式： $$ \sqrt{a}x $$ 表格：
   姓名 年龄 成绩           脚注：
一个问题1
横线：</description>
    </item>
    
    <item>
      <title>关于排序</title>
      <link>https://Mortyda.github.io/ablog/</link>
      <pubDate>Tue, 24 May 2022 14:10:51 +0800</pubDate>
      
      <guid>https://Mortyda.github.io/ablog/</guid>
      <description>排序   稳定性 (排序前A在B前B，排序后A=B，A仍在B前)
  内排序（排序记录均放置在内存中）与外排序： 内排序性能:
 时间性能：关键字比较次数及记录移动次数应尽可能少 辅助空间：存放待排序及算法运行所用空间 复杂性：算法复杂性影响排序性    #define MAXSIZE 10 //数组个数最大值 struct SqList{  int r[MAXSIZE+1];//储存要排序的数组  int length; } void swap(SqList *L,int i,int j){  int temp=L-&amp;gt;r[i];  L-&amp;gt;r[i]=L-&amp;gt;r[j];  L-&amp;gt;r[j]=temp; } 排序种类 插入排序：好：0 moves, n-1 comparisons 坏：（n-1）n/2 moves 和comparisons n位swap
归并排序：T(n)=2*T([n/2])+cn
快速排序： 坏：（n-1）n/2 moves comparisons
插入排序   直接插入排序：将一个记录插入到已知有序序列中。
void InsertSort(SqList *L) {  for(int i=2;i&amp;lt;L-&amp;gt;length;i++)  {  if(L-&amp;gt;r[i]&amp;lt;L-&amp;gt;r[i-1])  {  L-&amp;gt;r[0]=L-&amp;gt;r[i];//哨兵r[0]用于存储需要插入的记录  for(int j=i-1;L-&amp;gt;r[j]&amp;gt;L-&amp;gt;r[i];j--)//遍历必r[0]大的记录并后移  {  L-&amp;gt;r[j+1]=L-&amp;gt;[j];  }  L-&amp;gt;r[j]=L-&amp;gt;r[0];//将数据r[0]放入空位  }  } }   希尔排序：设定一个增量序列（质数序列，递减，最终为1），将以每一个增量作为间隔的少数记录做一次直接插入排序，由基本有序逐渐完善到整体有序。</description>
    </item>
    
    <item>
      <title>关于排序</title>
      <link>https://Mortyda.github.io/post/ablog/</link>
      <pubDate>Tue, 24 May 2022 14:10:51 +0800</pubDate>
      
      <guid>https://Mortyda.github.io/post/ablog/</guid>
      <description>排序   稳定性 (排序前A在B前B，排序后A=B，A仍在B前)
  内排序（排序记录均放置在内存中）与外排序： 内排序性能:
 时间性能：关键字比较次数及记录移动次数应尽可能少 辅助空间：存放待排序及算法运行所用空间 复杂性：算法复杂性影响排序性    #define MAXSIZE 10 //数组个数最大值 struct SqList{  int r[MAXSIZE+1];//储存要排序的数组  int length; } void swap(SqList *L,int i,int j){  int temp=L-&amp;gt;r[i];  L-&amp;gt;r[i]=L-&amp;gt;r[j];  L-&amp;gt;r[j]=temp; } 排序种类 插入排序：好：0 moves, n-1 comparisons 坏：（n-1）n/2 moves 和comparisons n位swap
归并排序：T(n)=2*T([n/2])+cn
快速排序： 坏：（n-1）n/2 moves comparisons
插入排序   直接插入排序：将一个记录插入到已知有序序列中。
void InsertSort(SqList *L) {  for(int i=2;i&amp;lt;L-&amp;gt;length;i++)  {  if(L-&amp;gt;r[i]&amp;lt;L-&amp;gt;r[i-1])  {  L-&amp;gt;r[0]=L-&amp;gt;r[i];//哨兵r[0]用于存储需要插入的记录  for(int j=i-1;L-&amp;gt;r[j]&amp;gt;L-&amp;gt;r[i];j--)//遍历必r[0]大的记录并后移  {  L-&amp;gt;r[j+1]=L-&amp;gt;[j];  }  L-&amp;gt;r[j]=L-&amp;gt;r[0];//将数据r[0]放入空位  }  } }   希尔排序：设定一个增量序列（质数序列，递减，最终为1），将以每一个增量作为间隔的少数记录做一次直接插入排序，由基本有序逐渐完善到整体有序。</description>
    </item>
    
  </channel>
</rss>
