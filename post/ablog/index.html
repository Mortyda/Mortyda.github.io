<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		

		<title>关于排序</title>

		
		<link rel="stylesheet" href="https://Mortyda.github.io/css/colors-dark.min.04ff1d6d2078fa65747fb72cef57eee0015c1b56e56c24eed85082032b2182f4.css">

		
	</head>
	<body>
		<header id="header">
			<h1><a href="https://Mortyda.github.io">ohhhhhhh</a></h1>
			<p>A wizard is never late</p>
		</header>

		<div id="page">
			<div id="sidebar">
				<nav>
	
		<ul class="nav">
			
				<li><a href="/index.xml"><span>Feed</span></a></li>
			
				<li><a href="https://github.com/bake/solar-theme-hugo/"><span>Repository</span></a></li>
			
		</ul>
	
		<ul class="nav">
			
				<li><a href="https://themes.gohugo.io/theme/solar-theme-hugo/"><span>Demo</span></a></li>
			
				<li><a href="https://themes.gohugo.io/solar-theme-hugo/"><span>Hugo</span></a></li>
			
		</ul>
	
</nav>

			</div>

			<div id="content">
				
	<article class="post">
		<h1><a href="https://Mortyda.github.io/post/ablog/">关于排序</a> </h1>

		<div class="post-content"><h1 id="排序">排序</h1>
<ol>
<li>
<p>稳定性 (排序前A在B前B，排序后A=B，A仍在B前)</p>
</li>
<li>
<p>内排序（排序记录均放置在内存中）与外排序：
内排序性能:</p>
<ol>
<li>时间性能：关键字比较次数及记录移动次数应尽可能少</li>
<li>辅助空间：存放待排序及算法运行所用空间</li>
<li>复杂性：算法复杂性影响排序性</li>
</ol>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#define MAXSIZE 10 </span><span style="color:#007f7f">//数组个数最大值
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">struct</span> SqList{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> r[MAXSIZE+<span style="color:#ff0;font-weight:bold">1</span>];<span style="color:#007f7f">//储存要排序的数组
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> length;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> swap(SqList *L,<span style="color:#fff;font-weight:bold">int</span> i,<span style="color:#fff;font-weight:bold">int</span> j){
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> temp=L-&gt;r[i];
</span></span><span style="display:flex;"><span>    L-&gt;r[i]=L-&gt;r[j];
</span></span><span style="display:flex;"><span>    L-&gt;r[j]=temp;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="排序种类">排序种类</h2>
<p><img src="C:%5CUsers%5C%E5%91%A8%E5%AE%8F%E8%BE%BE%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220517195024192.png" alt="image-20220517195024192"></p>
<p>插入排序：好：0 moves, n-1 comparisons  坏：（n-1）n/2 moves 和comparisons  					n位swap</p>
<p>归并排序：T(n)=2*T([n/2])+cn</p>
<p>快速排序： 坏：（n-1）n/2 moves comparisons</p>
<h3 id="插入排序">插入排序</h3>
<ol>
<li>
<p>直接插入排序：将一个记录插入到已知有序序列中。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> InsertSort(SqList *L)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> i=<span style="color:#ff0;font-weight:bold">2</span>;i&lt;L-&gt;length;i++)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span>(L-&gt;r[i]&lt;L-&gt;r[i-<span style="color:#ff0;font-weight:bold">1</span>])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            L-&gt;r[<span style="color:#ff0;font-weight:bold">0</span>]=L-&gt;r[i];<span style="color:#007f7f">//哨兵r[0]用于存储需要插入的记录
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>            <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> j=i-<span style="color:#ff0;font-weight:bold">1</span>;L-&gt;r[j]&gt;L-&gt;r[i];j--)<span style="color:#007f7f">//遍历必r[0]大的记录并后移
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>            {
</span></span><span style="display:flex;"><span>                L-&gt;r[j+<span style="color:#ff0;font-weight:bold">1</span>]=L-&gt;[j];              
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            L-&gt;r[j]=L-&gt;r[<span style="color:#ff0;font-weight:bold">0</span>];<span style="color:#007f7f">//将数据r[0]放入空位
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>希尔排序：设定一个增量序列（质数序列，递减，最终为1），将以每一个增量作为间隔的少数记录做一次直接插入排序，由基本有序逐渐完善到整体有序。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> ShellSort(SqList *L)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> increment=L-&gt;length;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">do</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        increment=incrament/<span style="color:#ff0;font-weight:bold">3</span>+<span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> i=increment+<span style="color:#ff0;font-weight:bold">1</span>;i&lt;=L-&gt;length;i++)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">if</span>(L-&gt;r[i]&lt;L-&gt;r[i-increment])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                L-&gt;r[<span style="color:#ff0;font-weight:bold">0</span>]=L-&gt;r[i];
</span></span><span style="display:flex;"><span>                <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> j=i-increment;j&gt;<span style="color:#ff0;font-weight:bold">0</span>&amp;&amp;L-&gt;r[<span style="color:#ff0;font-weight:bold">0</span>]&lt;L-&gt;r[j];j-=increment)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    L-&gt;r[j+increment]=L-&gt;r[<span style="color:#ff0;font-weight:bold">0</span>];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span>(increment&gt;<span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ol>
<h3 id="交换排序">交换排序</h3>
<ol>
<li>
<p>冒泡排序：</p>
</li>
<li>
<p>快速排序：设计一个中心枢纽，枢纽左边的都是比他小的，右边的都是比他大的。左右边部分继续设置枢纽，进行排序，依此递归。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> QuickSort(SqList *L)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    QSort(L,<span style="color:#ff0;font-weight:bold">1</span>,L-&gt;length);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> QSort(SqList *L,<span style="color:#fff;font-weight:bold">int</span> low,<span style="color:#fff;font-weight:bold">int</span> high)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> pivot;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(low&lt;high)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        pivot=Partition(L,low,high);
</span></span><span style="display:flex;"><span>        QSort(L,low,pivot-<span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>        QSort(L,pivot+<span style="color:#ff0;font-weight:bold">1</span>,high);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> Partition(SqList *L,<span style="color:#fff;font-weight:bold">int</span> low,<span style="color:#fff;font-weight:bold">int</span> high)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> pivotKey;
</span></span><span style="display:flex;"><span>    pivotkey=L-&gt;r[low];
</span></span><span style="display:flex;"><span>    L-&gt;r[<span style="color:#ff0;font-weight:bold">0</span>]=pivotkey;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span>(low&lt;high)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey){high--;}
</span></span><span style="display:flex;"><span>        L-&gt;r[low]=L-&gt;r[high];
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span>(low&gt;high&amp;&amp;L-&gt;[low]&lt;=pivotkey){low++}
</span></span><span style="display:flex;"><span>        L-&gt;r[high]=L-&gt;r[low];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    L-&gt;r[llow]=L-&gt;r[<span style="color:#ff0;font-weight:bold">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> low;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ol>
<h3 id="选择排序">选择排序</h3>
<ol>
<li>直接选择排序</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> SelectSort(SqList *L)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> i,j,min;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">for</span>(i=<span style="color:#ff0;font-weight:bold">1</span>;i&lt;L-&gt;length;i++)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    min=i;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(j=i+<span style="color:#ff0;font-weight:bold">1</span>;j&lt;L-&gt;length;j++)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span>(L-&gt;r[j]&lt;L-&gt;r[min])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            min=j;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(i!=min)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        swap(L,min,i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>堆排序</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> HeapSort(SqList *L)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(i=L-&gt;length/<span style="color:#ff0;font-weight:bold">2</span>;i&gt;<span style="color:#ff0;font-weight:bold">0</span>;i--)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        HeapAdjust(L,i,L-&gt;length);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(i=L-&gt;length;i&gt;<span style="color:#ff0;font-weight:bold">1</span>;i--)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        swap(L,<span style="color:#ff0;font-weight:bold">1</span>,i);
</span></span><span style="display:flex;"><span>        HeapAdjust(L,<span style="color:#ff0;font-weight:bold">1</span>,i-<span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> HeapAdjust(Aqlist *L,<span style="color:#fff;font-weight:bold">int</span> s,<span style="color:#fff;font-weight:bold">int</span> m)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> temp,j;
</span></span><span style="display:flex;"><span>    temp=L-&gt;r[s];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(j=<span style="color:#ff0;font-weight:bold">2</span>*s;j&lt;m;j*=<span style="color:#ff0;font-weight:bold">2</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span>(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+<span style="color:#ff0;font-weight:bold">1</span>])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            ++j;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span>(temp&gt;=L-&gt;r[j])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        L-&gt;r[s]=L-&gt;r[j];
</span></span><span style="display:flex;"><span>        s=j;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    L-&gt;r[s]=temp;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>###　归并排序</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> MergeSort(SqList *L)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    MSort(L-&gt;r,L-&gt;r,<span style="color:#ff0;font-weight:bold">1.</span>L-&gt;length);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>voidMSort(<span style="color:#fff;font-weight:bold">int</span> SR[],<span style="color:#fff;font-weight:bold">int</span> TR[],<span style="color:#fff;font-weight:bold">int</span> s,<span style="color:#fff;font-weight:bold">int</span> t)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> m;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> TR2[MAXSIZE+<span style="color:#ff0;font-weight:bold">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(s==t)
</span></span><span style="display:flex;"><span>    {TR1[s]=SR[s];}
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        m=(s+t)/<span style="color:#ff0;font-weight:bold">2</span>;
</span></span><span style="display:flex;"><span>        MSort(SR,TR,s,m);
</span></span><span style="display:flex;"><span>        MSort(SR,TR,m+<span style="color:#ff0;font-weight:bold">1</span>,t);
</span></span><span style="display:flex;"><span>        Merge(TR2,TR1,s,m,t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> Merge(<span style="color:#fff;font-weight:bold">int</span> SR[],<span style="color:#fff;font-weight:bold">int</span> TR[],<span style="color:#fff;font-weight:bold">int</span> i,<span style="color:#fff;font-weight:bold">int</span> m,<span style="color:#fff;font-weight:bold">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (SR[i]&lt;SR[j])
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        TR[K]=SR[i++];
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">else</span>{TR[k]=SR[j++];}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">if</span>(i&lt;=m)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(l=<span style="color:#ff0;font-weight:bold">0</span>;l&lt;m-i,l++
</span></span><span style="display:flex;"><span>        {TR[k+<span style="color:#ff0;font-weight:bold">1</span>]=SR[i+<span style="color:#ff0;font-weight:bold">1</span>];}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">if</span>(j&lt;=n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(l=<span style="color:#ff0;font-weight:bold">0</span>;l&lt;n-j,l++
</span></span><span style="display:flex;"><span>        {TR[k+<span style="color:#ff0;font-weight:bold">1</span>]=SR[i+<span style="color:#ff0;font-weight:bold">1</span>];}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="冒泡排序">冒泡排序</h3>
<p>两两比较相邻记录关键字，反序则交换，直到没有反序。</p>
<p>以下为初级冒泡排序（交换排序），遍历数组，每一次都与后面的记录比较，每一次都在第i位（初始位）得到最小值，最后得到由小到大的数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> BubbleSort0(SqList *L)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>;i&lt;L-&gt;length;i++){
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> j=i+<span style="color:#ff0;font-weight:bold">1</span>;j&lt;L-&gt;length;j++){
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">if</span> (L-&gt;r[i]&gt;L-&gt;r[j]){
</span></span><span style="display:flex;"><span>                swap(L,i,j)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#f00">经典冒泡</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> BubbleSort1(SqList *L){
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> i;i&lt;L-&gt;length;i++){
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> j=L-&gt;length;j&gt;=i;j--){
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span style="color:#ff0;font-weight:bold">1</span>]){
</span></span><span style="display:flex;"><span>                swap(L,j,j+<span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>优化：通过添加标记省略无意义的循环比较</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> BubbleSort2(SqList *L){
</span></span><span style="display:flex;"><span>    status flag=True;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> i;i&lt;L-&gt;length&amp;&amp;flag;i++){
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> j=L-&gt;length;j&gt;=i;j--){
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span style="color:#ff0;font-weight:bold">1</span>]){
</span></span><span style="display:flex;"><span>                swap(L,j,j+<span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>            falg=FALSE;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>时间复杂度:O(n^2)</p>
</div>

		<p class="meta">Posted on <span class="postdate">24. May 2022</span></p>
	</article>

			</div>

			<footer id="footer">
				<p class="copyright">
					
						Powered by <a href="https://gohugo.io/">Hugo</a> and the
						<a href="https://github.com/bake/solar-theme-hugo">Solar</a>-theme.
					
				</p>
			</footer>
		</div>

		
	</body>
</html>
